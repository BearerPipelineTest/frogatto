{
	id: "scroll_bar_vertical",
	is_strict: true,
	use_absolute_screen_coordinates: true,

	properties: {
		_scroll_area: { type: "obj scrollable_area" },

		scrollbar_width: "8",
		scrollbar_height: "_scroll_area.viewport_height",
		scrollbar_color: { type: "Color", default: [128,128,128] },
		
		handle_color: { type: "Color", default: [255,255,255] },
		handle_height: "int :: lib.math.round(max(1.0, _scroll_area.viewport_height / _scroll_area.interior_dimensions.h))",

//		max_pos: { type: "decimal" },
//		max_handle_pos: "decimal :: max_pos - handle_height",

//		handle_pos: {
//			type: "decimal",
//			set: "if(actual_value != _data, [
//				set(_data, actual_value),
//				if(handle, set(handle.y, y + int(actual_value*(scrollbar_height/max_pos))))
//			]; if(handle_scroll != null, handle_scroll(value))
//			) where actual_value = clamp(value, 0.0, max_handle_pos)"
//		},


		handle: { type: "null|obj scroll_bar_vertical.handle" },
		get_handle: "obj scroll_bar_vertical.handle<- handle",

		render: "def() ->commands
			set(animation, lib.gui.render_frame(c, scrollbar_width, scrollbar_height,
			[
				c.rectangle(0,0, scrollbar_width, scrollbar_height),
				c.set_source_color(lib.gui.color_normalize(scrollbar_color)),
				c.fill(),
			]))
			where c = canvas()
		",


		adjust_position: "def(int y_offset) -> commands [
			_scroll_area.add_scroll_offset({x: 0, y: y_offset})
		]",
		set_position: "def(int y_offset) -> commands [
			_scroll_area.set_scroll_offset({x: _scroll_area.scroll_offset.x, y: y_offset})
		]",
	},

	events: {
		mouse_wheel: "adjust_position( -step_size * arg.yscroll) where step_size = 20",
		create: "render();
		spawn('scroll_bar_vertical.handle', {
			x: x,
			y: y, //+ int(handle_pos*scrollbar_height/max_pos),
			handle_color: handle_color,
			zorder: zorder+1,
			_scrollbar: me,
		}, [
			set(me.handle, child),
		]
		)

//		;if(not shown, [set(alpha, 0); set(get_handle.alpha, 0)],
//		              [set(alpha, 128); set(get_handle.alpha, 128)])
		",

		click: "swallow_mouse_event();
			if(mouse_y < get_handle.y,
			   adjust_position(-handle_height),
			   mouse_y > get_handle.y2,
			   adjust_position(handle_height)
			)
			where mouse_y = lib.gui.mouse_pos(level)[1]
		",

		being_removed: "remove_object(handle)",
	},

	object_type: [{
		id: "handle",
		use_absolute_screen_coordinates: true,
		mouse_drag_threshold: 2,
		properties: {
			_scrollbar: { type: "obj scroll_bar_vertical" },
			handle_width: "int :: _scrollbar.scrollbar_width",
			handle_height: "int :: _scrollbar.handle_height",

			render: "def() ->commands
				set(animation, lib.gui.render_frame(c, handle_width, handle_height,
				[
					c.rectangle(0, 0, handle_width, handle_height),
					c.set_source_color(lib.gui.color_normalize(handle_color)),
					c.fill(),
				]))
				where c = canvas()
			",

			handle_color: { type: "Color" },

			_drag_pos: { type: "null|int" },
			_start_drag: { type: "null|decimal" },
		},

		events: {
			create: "render(); set(alpha, 128)",
			mouse_enter: "animate(me, { alpha: 255 }, { duration: 10 })",
			mouse_leave: "animate(me, { alpha: 128 }, { duration: 10 })",

			drag_start: "[
				swallow_mouse_event(),
				set(_drag_pos, mouse_y),
				set(_start_drag, _scrollbar._scroll_area.scroll_offset.y),
			]
				where mouse_y = lib.gui.mouse_pos(level)[1]",

			drag: "if(_drag_pos != null and _start_drag != null, [
				swallow_mouse_event(),
//				_scrollbar.set_position( int(_start_drag + (mouse_y - _drag_pos)*(_scrollbar.max_pos/_scrollbar.scrollbar_height))),
			])
				where mouse_y = lib.gui.mouse_pos(level)[1]",
			
			click: "swallow_mouse_event()",
		},
	}]
}
