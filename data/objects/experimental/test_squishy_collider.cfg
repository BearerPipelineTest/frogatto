{
id: "test_squishy_collider",
	is_strict: true,
	prototype: ["cosmetic_effects"],
	editor_info: {
		category: "experimental",
	},
	solid_area: [0,0,31,31],

	//has_feet: false,
	properties: {
		_last_triggered_squish_animation: { type:"int", default: 0 },
		springiness: "175",
		
		set_squish_animation_draw_bounds: "commands ::
			set(custom_draw, [0.0,1.0,2.0,3.0,
				[
					mag * ( 1.0 - squish_animation_progress) * (-0.6),
					mag * ( 1.0 - squish_animation_progress) * (1.6)
				],
				[
					mag * (-1.0 + squish_animation_progress) * (-0.6),
					mag * ( 1.0 - squish_animation_progress) * (1.6)
				],
				[
					mag * (-1.0 + squish_animation_progress) * (-0.3),
					0.0
				],
				[
					mag * ( 1.0 - squish_animation_progress) * (-0.3),
					0.0
				]
			]) where mag = min(me.img_w/2.0, me.img_h/2.0)",
		
		/*
			The draw area is done not via a normalized fraction (0.0 -> 1.0), but is done via direct pixel numbers.  Because of this, since we want to convert over to using a fraction, so that this works on any piece of art, we need to set the `mag` (magnitude) value to something appropriate (if it is less than the graphic's dimensions, it's relatively harmless; it just won't fully compress.  However, if it's more than the graphic's dimensions, it'll actually move the x1 value past the x2 one, and we'll essentially get a spatially inverted graphic, which sometimes leads to weird drawing errors (like the final shape being an hourglass shape).
			
			As such, we're grabbing the smaller value of img_w and img_h; whichever one won't distort the shape by overflowing.
		*/
			

		squish_animation_progress: {
			type: "decimal",
			init: "1.0",
			get: "_data",
			set: "[set(_data,value), set_squish_animation_draw_bounds]",
		},

		trigger_squish_animation: "commands :: 
			if(level.cycle - _last_triggered_squish_animation > 30,
				[
					set(_last_triggered_squish_animation, level.cycle),
					animate(me,
						{
							squish_animation_progress: 0.0
						},
						{
							duration: 10,
							easing: lib.math.ease_in_sine,
							on_complete: reverse_squish_animation,
						}
					),
				]
			)",

		reverse_squish_animation: "animate(me,
			{
				squish_animation_progress: 1.0
			},
			{
				duration: 20,
				easing: lib.math.ease_out_elastic,
			}
		)",
	},


	on_bounced_on: "[trigger_squish_animation]",



	animation: {
		id: "normal",
		image: "statusbar.png",
		rect: [139,8,170,39],
	},
}