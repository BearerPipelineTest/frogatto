{
	instances: [
	{
		//Shadow for drawing an 'iris' transition effect. It looks for
		//Frogatto in the level, finds out where he is in screen space
		//and then blacks out everything except a circle around him.
		//The circle's size is proportional to how far along the
		//transition is.
		name: "iris_transition",
		new: true,
		vertex: """
			uniform mat4 u_anura_mvp_matrix;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		""",

		fragment: """
           	#version 120
			uniform sampler2D u_anura_tex_map;
			uniform float u_anura_cycle;

			//player's position in screen space.
			uniform vec2 u_player_pos;
			uniform vec4 u_anura_draw_area;

			//value which is 0.0 when the transition has just started
			//and 1.0 when the transition is complete.
			uniform float u_transition_ratio;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				float dist_x = v_texcoord.x - u_player_pos.x;
				float dist_y = v_texcoord.y - u_player_pos.y;

				float dist = dist_x*dist_x + dist_y*dist_y;

				float max_dist = (1.0 - u_transition_ratio)*(1.0 - u_transition_ratio)*0.7;


				if(dist > max_dist) {
					gl_FragColor = vec4(0.0,0.0,0.0,1.0);
				} else {
					gl_FragColor = texture2D(u_anura_tex_map, v_texcoord);
					if(gl_FragColor.a > 0.02) {
						gl_FragColor.a = 1.0;
					}
				}
			}
		""",

		draw: """[
			set(uniform_commands.u_transition_ratio, level.transition_ratio),
			if(frogatto, [
				set(uniform_commands.u_player_pos, [
					(frogatto.mid_x - level.camera_position[0])/decimal(level.camera_position[2]),
					1.0 - (frogatto.mid_y - level.camera_position[1])/decimal(level.camera_position[3]),
				])
			]),
		] where frogatto = find(level.chars, value is obj frogatto_playable)""",
	},

	{
		name: "water_distort",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			uniform sampler2D u_water_tex;
			uniform float u_water_tex_dim;
			uniform float u_water_tex_speed;
			uniform vec4 u_camera_pos;
			//uniform float u_intensity;
			uniform vec4 u_water_area[8];
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				vec4 blend_color = vec4(0.0,0.0,0.0,0.0);
				vec2 texcoord = v_texcoord;
				
				for(int n = 0; n != 8; ++n) {
					if(u_water_area[n][0] >= u_water_area[n][2]) {
						break;
					}

					float left = max(u_anura_draw_area[0], u_water_area[n][0]);
					float top = max(u_anura_draw_area[1], u_water_area[n][1]);
					float right = min(u_anura_draw_area[2], u_water_area[n][2]);
					float bottom = min(u_anura_draw_area[3], u_water_area[n][3]);
					if(v_vertex.x > left
					   && v_vertex.y > top
					   && v_vertex.x < right 
					   && v_vertex.y < bottom){
						float falloff_ratio = min(min(v_vertex.x - left, right - v_vertex.x)/40.0,1.0);
						texcoord.x = texcoord.x + falloff_ratio*sin((u_anura_draw_area[0] + v_vertex.x)*0.02 + u_anura_cycle/20.0)/300.0;
						vec2 loc = vec2(u_camera_pos[0]/u_anura_draw_area[2], -u_camera_pos[1]/u_anura_draw_area[3]) + texcoord;
						loc.x *= u_anura_draw_area[2]/u_water_tex_dim;
						loc.y *= u_anura_draw_area[2]/u_water_tex_dim;
						blend_color = (texture2D(u_water_tex, loc + vec2(u_anura_cycle*u_water_tex_speed, 0.0)) + texture2D(u_water_tex, loc + vec2(u_anura_cycle*u_water_tex_speed, 0.5)))*0.5; //vec4(0.0,200/255.0,150/255.0,0.5);
					}
				}
				vec4 fb_color = texture2D(u_anura_tex_map, texcoord);
				float fb_grayscale = (fb_color[0] + fb_color[1] + fb_color[2])/3.0;

				vec4 search_left = texture2D(u_anura_tex_map, texcoord + vec2(-10.0/u_anura_draw_area[2], 0.0));
				vec4 search_right = texture2D(u_anura_tex_map, texcoord + vec2(+10.0/u_anura_draw_area[2], 0.0));
				vec4 search_down = texture2D(u_anura_tex_map, texcoord + vec2(0.0, +10.0/u_anura_draw_area[2]));

				float grayscale_left = search_left[0] + search_left[1] + search_left[2];
				float grayscale_right = search_right[0] + search_right[1] + search_right[2];
				float grayscale_down = search_down[0] + search_down[1] + search_down[2];

				if(fb_grayscale < 0.02 || grayscale_left < 0.02 || grayscale_right < 0.02 || grayscale_down < 0.02) {
					float grayscale_threshold = 0.35;
					if(fb_grayscale < grayscale_threshold) {
						blend_color[3] *= fb_grayscale / grayscale_threshold;
					}
				}


				gl_FragColor = mix(fb_color, blend_color, blend_color[3]);
			}
		",

		draw: "[
			if(water_rects, 
				[
					set(uniform_commands.u_water_area, fold(water_rects_terminated[:8], a+b))
						where water_rects_terminated = water_rects + [[0,0,0,0]],
					bind_texture(water_tex, 2),
					set(uniform_commands.u_water_tex, 2),
					set(uniform_commands.u_water_tex_dim, ctrl.texture_dim),
					set(uniform_commands.u_water_tex_speed, ctrl.texture_speed),
					set(uniform_commands.u_camera_pos, level.camera_position),
					set(textures, [water_tex]),
				] where water_tex = ctrl.get_texture
				  where ctrl = find_or_die(level.chars, value is obj water_controller or value is obj whitewater_controller or value is obj water_controller_rising),
				
				set(uniform_commands.u_water_area, [0,0,0,0])
			),
		] where water_rects = (
			[ 
				[water._x_bound - pos[0], water._y_bound - pos[1], water._x2_bound - pos[0], water._y2_bound - pos[1]]
				| water <- level.chars,
				  water is obj water_controller or water is obj whitewater_controller or value is obj water_controller_rising,
				  rects_intersect([water._x_bound, water._y_bound, water._x2_bound, water._y2_bound], camera_rect)
			] where camera_rect = [pos[0], pos[1], pos[0]+pos[2], pos[1]+pos[3]]
			  where pos = level.camera_position
		)"
	},

	{
		name: "acid_distort",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			uniform sampler2D u_water_tex;
			uniform float u_water_tex_dim;
			uniform float u_water_tex_speed;
			uniform vec4 u_camera_pos;
			//uniform float u_intensity;
			uniform vec4 u_water_area[8];
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				vec4 blend_color = vec4(0.0,0.0,0.0,0.0);
				vec2 texcoord = v_texcoord;
				
				/*
					This steps over multiple water areas - it artificially limits itself to the first 8 water areas that are onscreen (this gets done not here, in the `fragment` call, but down in the `draw` call below).
					
					The final return value is a single pixel's color.
					
					Since of course this is a shader, the end result we're going for is just one single pixel's color, so any 'scanning over multiple pixels' is just to get ingredients, not to output more than one. 
				*/
				for(int n = 0; n != 8; ++n) {

						//If a water rect's has negative width, don't do anything.  Any checks like this will leave us with the default colors (set above), which conveniently happen to be 'transparent', so the shader won't mess up any unintended pixels. 
					if(u_water_area[n][0] >= u_water_area[n][2]) {
						break;
					}

					float left = max(u_anura_draw_area[0], u_water_area[n][0]);
					float top = max(u_anura_draw_area[1], u_water_area[n][1]);
					float right = min(u_anura_draw_area[2], u_water_area[n][2]);
					float bottom = min(u_anura_draw_area[3], u_water_area[n][3]);
					
						//just do a quick bounds check
					if(	v_vertex.x > left
						&& v_vertex.y > top
						&& v_vertex.x < right 
						&& v_vertex.y < bottom
					){
					
						/*
							This is the heart of our 'distortion'; right now, this works by only 'wobbling' the x-coord of the pixel; basically we decide to sample from a different point in the source texture, based on the current timestamp.
							
							`falloff_ratio` is a 0.0~1.0 float; it attenuates how much horizontal distortion there is.  The idea is that when we get closer to the edge of the water rectangle, we want to reduce the amount of distortion - asymptotically approaching no movement at all when we're flush with the edge of the rectangle.  There are two reasons for this - the first one is that it lines up with how fluid dynamics work IRL - actual liquids in i.e. a Pipe barely move near the edges of it, and have their highest flow out in the middle.   It also, conveniently, completely kills any problems of 'seaming' at the edge of the rectangle.
						*/
						float falloff_ratio = min(min(v_vertex.x - left, right - v_vertex.x)/40.0,1.0);
						
						texcoord.x = texcoord.x + falloff_ratio*sin((u_anura_draw_area[0] + v_vertex.x)*0.02 + u_anura_cycle/20.0)/300.0;
						

						/*
							The following several lines of code basically are figuring out an XY point - their goal is basically let us 'draw the water texture' by essentially deciding where the final pixel is on the screen, and using that to decide where, in the water texture, we should be sampling.  If they're all offset consistently, we'll just be sampling one-by-one and basically 'redrawing' the water texture wherever we want it, pixel by pixel.
						*/
						
						/*
							This adds two XY points together - GLSL has a convenience where adding two points like this automatically adds the components piecewise.
							
							`u_camera_pos` is essentially 'level space integers'; so i.e. 200,250 for x,y if the camera's upper corner is there.
							`u_anura_draw_area` here is an XYWH rect, so this means it's just plucking the width/height values here.
							
							This is extracting a 'fraction' here (normalized 0.0~1.0), of where we're at on the screen.
						*/
						vec2 loc = vec2(u_camera_pos[0]/u_anura_draw_area[2], -u_camera_pos[1]/u_anura_draw_area[3]) + texcoord;

						/*
							Then we take that and divide it against the dimensions of the water texture — again, yielding a fraction.  This is meant to tell us where in the water texture we want to sample.  This handles the issue of 'repeating' the texture horizontally and vertically.
						*/
						loc.x *= u_anura_draw_area[2]/u_water_tex_dim;
						loc.y *= u_anura_draw_area[2]/u_water_tex_dim;  //<-- this should probably be u_anura_draw_area[3]?
						
						
						/*
							Finally, we do a little bit of weird mumbo-jumbo to make the end product look a little more organic.
							
							Rather than doing the 'expected' act of just plopping in a obvious 'single' texture lookup, we're actually doing *two* of them, and taking the average of the two values.  The reason for this is a cheap attempt at making two textures instead of one (essentially just making two 'layers' of the same texture on the screen).  This is meant to make it look a little bit more organic - we might switch this around in the future, but that's all this is doing.
						*/
						
						blend_color =	(
											texture2D(u_water_tex, loc + vec2(u_anura_cycle*u_water_tex_speed, 0.0)) +
											texture2D(u_water_tex, loc + vec2(u_anura_cycle*u_water_tex_speed, 0.5))
										)*0.5; //vec4(0.0,200/255.0,150/255.0,0.5);
					}
				}
				
				
				
				/*
					This section does an implementation of a 'blend mode' for the whole chunk of water.
					
					We start by sampling the frame buffer (i.e. the screenshot of what's on the level already), and pluck the pixel we're looking at, and ask 'what is the brightness of the pixel' - we're asking for the overall brightness, so we don't care about the hue data, we just covert to grayscale. 
				*/
				vec4 fb_color = texture2D(u_anura_tex_map, texcoord);
				float fb_grayscale = (fb_color[0] + fb_color[1] + fb_color[2])/3.0;

				/*
					This section does something fairly unintuitive - basically it's trying to limit which pixels we actually bother to apply the blend mode to - it's specifically trying to make it so none of them get applied in the middle.
					
					If we just naively apply our blend-mode everywhere, unless we have a really specific type of blend mode, when it's applied with water layered over the 'jet black' fill color, it won't entirely fade to black.  In the most extreme case, if we just laid a water area over a block of completely solid tiles (i.e. just a giant rectangle of pure black on the screen), we'd end up with a slightly off-black ('tinged to blue') rectangle.   We see the same thing clipping out past the edges of 'real' water areas, where there's an open-space for the water to sit.
					
					What we want is to have this absolutely fade to complete black if the pixels underneath are, themselves, jet black, so we can use any blending we want, and not just certain blend modes that will naturally 'fade to black'.
					
					
					One oddity you'll notice here is we don't do a search-up; this is probably due to how water has a surface at the top - so our sampling is not a + sign, but rather a T shape.
				*/
				vec4 search_left = texture2D(u_anura_tex_map, texcoord + vec2(-10.0/u_anura_draw_area[2], 0.0));
				vec4 search_right = texture2D(u_anura_tex_map, texcoord + vec2(+10.0/u_anura_draw_area[2], 0.0));
				vec4 search_down = texture2D(u_anura_tex_map, texcoord + vec2(0.0, +10.0/u_anura_draw_area[2]));

				float grayscale_left = search_left[0] + search_left[1] + search_left[2];
				float grayscale_right = search_right[0] + search_right[1] + search_right[2];
				float grayscale_down = search_down[0] + search_down[1] + search_down[2];

				/*
					The 0.02 values here are basically an 'epsilon value' to make sure we catch 'very close to black'.
				*/
				if(fb_grayscale < 0.02 || grayscale_left < 0.02 || grayscale_right < 0.02 || grayscale_down < 0.02) {
				
					//finally, the actual blend mode:
					float grayscale_threshold = 0.35;
					if(fb_grayscale < grayscale_threshold) {
						blend_color[3] *= fb_grayscale / grayscale_threshold;
					}
				}


				gl_FragColor = mix(fb_color, blend_color, blend_color[3]);
			}
		",

		draw: "[
			if(water_rects, 
				[
					set(uniform_commands.u_water_area, fold(water_rects_terminated[:8], a+b))
						where water_rects_terminated = water_rects + [[0,0,0,0]],
					bind_texture(water_tex, 2),
					set(uniform_commands.u_water_tex, 2),
					set(uniform_commands.u_water_tex_dim, ctrl.texture_dim),
					set(uniform_commands.u_water_tex_speed, ctrl.texture_speed),
					set(uniform_commands.u_camera_pos, level.camera_position),
					set(textures, [water_tex]),
				] where water_tex = ctrl.get_texture
				  where ctrl = find_or_die(level.chars, value is obj acid_controller or value is obj acid_deadly_controller),
				
				set(uniform_commands.u_water_area, [0,0,0,0])
			),
		] where water_rects = (
			[ 
				[water._x_bound - pos[0], water._y_bound - pos[1], water._x2_bound - pos[0], water._y2_bound - pos[1]]
				| water <- level.chars,
				  water is obj acid_controller or water is obj acid_deadly_controller,
				  rects_intersect([water._x_bound, water._y_bound, water._x2_bound, water._y2_bound], camera_rect)
			] where camera_rect = [pos[0], pos[1], pos[0]+pos[2], pos[1]+pos[3]]
			  where pos = level.camera_position
		)"
	},

	{
		name: "new_acid_distort",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			uniform sampler2D u_water_tex;
			uniform float u_water_tex_dim;
			uniform float u_water_tex_speed;
			uniform vec4 u_camera_pos;
			//uniform float u_intensity;
			uniform vec4 u_water_area[8];
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			
			float ease_out_circ(float t)
			{
				return sqrt(1.0 - pow( (t-1.0), 2.0 ) );
			}

			float ease_in_circ(float t)
			{
				return 1 - sqrt(1 - pow(t,2) );
			}
			
			void main()
			{
				vec4 blend_color = vec4(0.0,0.0,0.0,0.0);
				vec2 texcoord = v_texcoord;
				
				/*
					This steps over multiple water areas - it artificially limits itself to the first 8 water areas that are onscreen (this gets done not here, in the `fragment` call, but down in the `draw` call below).
					
					The final return value is a single pixel's color.
					
					Since of course this is a shader, the end result we're going for is just one single pixel's color, so any 'scanning over multiple pixels' is just to get ingredients, not to output more than one. 
				*/
				for(int n = 0; n != 8; ++n) {

						//If a water rect's has negative width, don't do anything.  Any checks like this will leave us with the default colors (set above), which conveniently happen to be 'transparent', so the shader won't mess up any unintended pixels. 
					if(u_water_area[n][0] >= u_water_area[n][2]) {
						break;
					}

					float left = max(u_anura_draw_area[0], u_water_area[n][0]);
					float top = max(u_anura_draw_area[1], u_water_area[n][1]);
					float right = min(u_anura_draw_area[2], u_water_area[n][2]);
					float bottom = min(u_anura_draw_area[3], u_water_area[n][3]);
					
						//just do a quick bounds check
					if(	v_vertex.x > left
						&& v_vertex.y > top
						&& v_vertex.x < right 
						&& v_vertex.y < bottom
					){
					
						/*
							This is the heart of our 'distortion'; right now, this works by only 'wobbling' the x-coord of the pixel; basically we decide to sample from a different point in the source texture, based on the current timestamp.
							
							`falloff_ratio` is a 0.0~1.0 float; it attenuates how much horizontal distortion there is.  The idea is that when we get closer to the edge of the water rectangle, we want to reduce the amount of distortion - asymptotically approaching no movement at all when we're flush with the edge of the rectangle.  There are two reasons for this - the first one is that it lines up with how fluid dynamics work IRL - actual liquids in i.e. a Pipe barely move near the edges of it, and have their highest flow out in the middle.   It also, conveniently, completely kills any problems of 'seaming' at the edge of the rectangle.
						*/
						float falloff_ratio = min(min(v_vertex.x - left, right - v_vertex.x)/40.0,1.0);
						
						texcoord.x = texcoord.x + falloff_ratio*sin((u_anura_draw_area[0] + v_vertex.x)*0.02 + u_anura_cycle/20.0)/300.0;
						

						/*
							The following several lines of code basically are figuring out an XY point - their goal is basically let us 'draw the water texture' by essentially deciding where the final pixel is on the screen, and using that to decide where, in the water texture, we should be sampling.  If they're all offset consistently, we'll just be sampling one-by-one and basically 'redrawing' the water texture wherever we want it, pixel by pixel.
						*/
						
						/*
							This adds two XY points together - GLSL has a convenience where adding two points like this automatically adds the components piecewise.
							
							`u_camera_pos` is essentially 'level space integers'; so i.e. 200,250 for x,y if the camera's upper corner is there.
							`u_anura_draw_area` here is an XYWH rect, so this means it's just plucking the width/height values here.
							
							This is extracting a 'fraction' here (normalized 0.0~1.0), of where we're at on the screen.
						*/
						vec2 loc = vec2(u_camera_pos[0]/u_anura_draw_area[2], -u_camera_pos[1]/u_anura_draw_area[3]) + texcoord;

						/*
							Then we take that and divide it against the dimensions of the water texture — again, yielding a fraction.  This is meant to tell us where in the water texture we want to sample.  This handles the issue of 'repeating' the texture horizontally and vertically.
						*/
						loc.x *= u_anura_draw_area[2]/u_water_tex_dim;
						loc.y *= u_anura_draw_area[2]/u_water_tex_dim;  //<-- this should probably be u_anura_draw_area[3]?
						
						
						/*
							Finally, we do a little bit of weird mumbo-jumbo to make the end product look a little more organic.
							
							Rather than doing the 'expected' act of just plopping in a obvious 'single' texture lookup, we're actually doing *two* of them, and taking the average of the two values.  The reason for this is a cheap attempt at making two textures instead of one (essentially just making two 'layers' of the same texture on the screen).  This is meant to make it look a little bit more organic - we might switch this around in the future, but that's all this is doing.
						*/
						
						blend_color =	(
											texture2D(u_water_tex, loc + vec2(u_anura_cycle*u_water_tex_speed, 0.0)) +
											texture2D(u_water_tex, loc + vec2(u_anura_cycle*u_water_tex_speed, 0.5))
										)*0.5; //vec4(0.0,200/255.0,150/255.0,0.5);
					}
				}
				
				
				
				/*
					This section does an implementation of a 'blend mode' for the whole chunk of water.
					
					We start by sampling the frame buffer (i.e. the screenshot of what's on the level already), and pluck the pixel we're looking at, and ask 'what is the brightness of the pixel' - we're asking for the overall brightness, so we don't care about the hue data, we just covert to grayscale. 
				*/
				vec4 fb_color = texture2D(u_anura_tex_map, texcoord);
				float fb_grayscale = (fb_color[0] + fb_color[1] + fb_color[2])/3.0;

				/*
					This section does something fairly unintuitive - basically it's trying to limit which pixels we actually bother to apply the blend mode to - it's specifically trying to make it so none of them get applied in the middle.
					
					If we just naively apply our blend-mode everywhere, unless we have a really specific type of blend mode, when it's applied with water layered over the 'jet black' fill color, it won't entirely fade to black.  In the most extreme case, if we just laid a water area over a block of completely solid tiles (i.e. just a giant rectangle of pure black on the screen), we'd end up with a slightly off-black ('tinged to blue') rectangle.   We see the same thing clipping out past the edges of 'real' water areas, where there's an open-space for the water to sit.
					
					What we want is to have this absolutely fade to complete black if the pixels underneath are, themselves, jet black, so we can use any blending we want, and not just certain blend modes that will naturally 'fade to black'.
					
					
					One oddity you'll notice here is we don't do a search-up; this is probably due to how water has a surface at the top - so our sampling is not a + sign, but rather a T shape.
				*/
				vec4 search_left = texture2D(u_anura_tex_map, texcoord + vec2(-10.0/u_anura_draw_area[2], 0.0));
				vec4 search_right = texture2D(u_anura_tex_map, texcoord + vec2(+10.0/u_anura_draw_area[2], 0.0));
				vec4 search_down = texture2D(u_anura_tex_map, texcoord + vec2(0.0, +10.0/u_anura_draw_area[2]));

				float grayscale_left = search_left[0] + search_left[1] + search_left[2];
				float grayscale_right = search_right[0] + search_right[1] + search_right[2];
				float grayscale_down = search_down[0] + search_down[1] + search_down[2];

				/*
					The 0.02 values here are basically an 'epsilon value' to make sure we catch 'very close to black'.
				*/
				
				//float final_fb_grayscale = min( fb_grayscale, min( grayscale_left, min( grayscale_right, grayscale_down )));
				//float final_fb_grayscale = (fb_grayscale + grayscale_left + grayscale_right + grayscale_down )/4.0;
				float final_fb_grayscale = fb_grayscale;
				
				//if(fb_grayscale < 0.02 || grayscale_left < 0.02 || grayscale_right < 0.02 || grayscale_down < 0.02) {
					//finally, the actual blend mode:
				/*
					if(final_fb_grayscale < 0.02) {
						float grayscale_threshold = 0.35;
						if(fb_grayscale < grayscale_threshold) {
							blend_color[3] *= fb_grayscale / grayscale_threshold;
						}
					}
				*/

				vec4 mostly_transparent_blend = blend_color;
				mostly_transparent_blend[3] *= final_fb_grayscale;
				
				vec4 linear_blend = mix(fb_color, blend_color, blend_color[3]);

				vec4 final_color = mix( mostly_transparent_blend, linear_blend,   ease_out_circ(final_fb_grayscale));
				

				gl_FragColor = final_color;
			}
		",

		draw: "[
			if(water_rects, 
				[
					set(uniform_commands.u_water_area, fold(water_rects_terminated[:8], a+b))
						where water_rects_terminated = water_rects + [[0,0,0,0]],
					bind_texture(water_tex, 2),
					set(uniform_commands.u_water_tex, 2),
					set(uniform_commands.u_water_tex_dim, ctrl.texture_dim),
					set(uniform_commands.u_water_tex_speed, ctrl.texture_speed),
					set(uniform_commands.u_camera_pos, level.camera_position),
					set(textures, [water_tex]),
				] where water_tex = ctrl.get_texture
				  where ctrl = find_or_die(level.chars, value is obj acid_controller or value is obj acid_deadly_controller),
				
				set(uniform_commands.u_water_area, [0,0,0,0])
			),
		] where water_rects = (
			[ 
				[water._x_bound - pos[0], water._y_bound - pos[1], water._x2_bound - pos[0], water._y2_bound - pos[1]]
				| water <- level.chars,
				  water is obj acid_controller or water is obj acid_deadly_controller,
				  rects_intersect([water._x_bound, water._y_bound, water._x2_bound, water._y2_bound], camera_rect)
			] where camera_rect = [pos[0], pos[1], pos[0]+pos[2], pos[1]+pos[3]]
			  where pos = level.camera_position
		)"
	},


	{
		name: "wind_distort",
		new: true,
		vertex: "
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			//uniform float u_intensity;
			uniform vec4 u_wind_area[2];
			uniform float u_wind_state;
			uniform float u_y1_positions[2];
			uniform float u_y2_positions[2];
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			//uniform vec4 u_anura_sprite_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				vec2 texcoord = v_texcoord;
				
				for(int n = 0; n != 2; ++n) {
					if(u_wind_area[n][0] >= u_wind_area[n][2]) {
						break;
					}

					float left = max(u_anura_draw_area[0], u_wind_area[n][0]);
					float top = max(u_anura_draw_area[1], u_wind_area[n][1]);
					float right = min(u_anura_draw_area[2], u_wind_area[n][2]);
					float bottom = min(u_anura_draw_area[3], u_wind_area[n][3]);
					if(v_vertex.x > left
					   && v_vertex.y > top
					   && v_vertex.x < right 
					   && v_vertex.y < bottom){

						float raw_ypos = (v_vertex.y - top)/(bottom - top);
						float normalized_ypos = u_y1_positions[n] + (u_y2_positions[n] - u_y1_positions[n])*raw_ypos;

						//TODO: we have the normalized_ypos which is in [0,1] and tells us how high within the wind
						//rectangle we are. Use this to calculate distortion which is by how much we will distort
						//pixels in the x-axis.
						float distortion =  sin(1.0 - normalized_ypos)*sin(u_anura_cycle*0.01)*0.05 +
											sin(1.0 - normalized_ypos)*(0.20 * u_wind_state);

						texcoord.x = texcoord.x + distortion;
					}
				}
				gl_FragColor = texture2D(u_anura_tex_map, texcoord);
			}
		",

		draw: "[if(wind_rects, set(uniform_commands.u_wind_area, fold(wind_rects[:2], a+b)),
							   set(uniform_commands.u_wind_area, [0,0,0,0])),
				set(uniform_commands.u_y1_positions, (y1_positions + [0,0])[:2]),
				set(uniform_commands.u_y2_positions, (y2_positions + [0,0])[:2]),
							   ]

		  where wind_rects = map(rect_info, value.area)
		  where y1_positions = map(rect_info, value.y1)
		  where y2_positions = map(rect_info, value.y2)
		  
		  where rect_info = (
		
		[ {
			area: [wind._x_bound - pos[0], wind._y_bound - pos[1], wind._x2_bound - pos[0], wind._y2_bound - pos[1]],
		    y1: max(0.0, decimal(camera_rect[1] - wind._y_bound)/(wind._y2_bound - wind._y_bound)),
		    y2: min(1.0, decimal(camera_rect[3] - wind._y_bound)/(wind._y2_bound - wind._y_bound)),
		  }

		  | wind <- level.chars,
			wind.type = 'wind_distortion_controller',
			rects_intersect([wind._x_bound, wind._y_bound, wind._x2_bound, wind._y2_bound], camera_rect)
		] where camera_rect = [pos[0], pos[1], pos[0]+pos[2], pos[1]+pos[3]]
		  where pos = level.camera_position
		)
		"
	}, 

	{
		name: "rain_distort",
		new: true,
		vertex: "
			//boiler plate vertex shader. Probably doesn't need modification. The fragment shader
			//is where the fun is.
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		fragment: "
			uniform sampler2D u_anura_tex_map;
			uniform sampler2D u_rain_tex;
			uniform float u_anura_cycle;
			uniform vec4 u_anura_draw_area;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;

			void main()
			{
				//right now this just gets the color from the frame buffer, gets the color from our
				//noise texture and 50/50 mixes the two.
				vec2 texcoord = v_texcoord;
				
				vec2 canvas_size = vec2(u_anura_draw_area[2], u_anura_draw_area[3]);
				vec2 rain_texcoord = texcoord*(canvas_size/vec2(256.0, 64.0));
				float animation_frame = floor(mod(floor(u_anura_cycle/5.0), 4.0));
				rain_texcoord.x = fract(rain_texcoord.x)/2.0 + animation_frame/4.0;
				rain_texcoord.y += u_anura_cycle/10.0;
				vec4 rain_col = texture2D(u_rain_tex, rain_texcoord);

				float cycle = fract(u_anura_cycle*0.15);
				float raw_translation = (rain_col.r / -0.19 / canvas_size.y);
				float translation = raw_translation * cycle * 2.0;
				vec4 fb_color_untranslated = texture2D(u_anura_tex_map,texcoord);
				texcoord.y=clamp(texcoord.y-translation * cycle, 0.0, 0.9999);
				vec4 fb_color = texture2D(u_anura_tex_map,texcoord);
				
				float alpha_level = clamp((cycle - 0.5) * 2.0, 0.0, 1.0);       // Controls rain opacity falloff
				fb_color = mix(fb_color, fb_color_untranslated, alpha_level);
				
				if(raw_translation < 0.0) {
   			 		fb_color = mix(fb_color, vec4(0.9, 0.9, 1.2, 0.1), 0.040);
				}
	

				//run another set of rain at a different phase.
				texcoord = v_texcoord;
				
				canvas_size = vec2(u_anura_draw_area[2], u_anura_draw_area[3]);
				rain_texcoord = texcoord*(canvas_size/vec2(256.0, 64.0));
				animation_frame = floor(mod(floor(u_anura_cycle/6.2), 4.0));
				rain_texcoord.x = fract(rain_texcoord.x)/2.0 + animation_frame/4.0;
				rain_texcoord.y += u_anura_cycle/11.2;
				rain_col = texture2D(u_rain_tex, rain_texcoord);

				cycle = fract(u_anura_cycle*0.23);
				raw_translation = (rain_col.r / -0.19 / canvas_size.y);
				translation = raw_translation * cycle * 2.0;
				fb_color_untranslated = fb_color;
				texcoord.y=clamp(texcoord.y-translation * cycle, 0.0, 0.9999);
				if(raw_translation < 0.0) {
					fb_color = texture2D(u_anura_tex_map,texcoord);
				}
				
				alpha_level = clamp((cycle - 0.5) * 2.0, 0.0, 1.0);       // Controls rain opacity falloff
				fb_color = mix(fb_color, fb_color_untranslated, alpha_level);
				
				if(raw_translation < 0.0) {
   			 		fb_color = mix(fb_color, vec4(0.9, 0.9, 1.2, 0.1), 0.080);
				}

				gl_FragColor = fb_color;
			}
		",

		draw: "
		[
		//fish the texture we want out of our controller. In future there will be a much nicer and easier way to do this.
		bind_texture(ctrl.rain_texture, 2),
		set(uniform_commands.u_rain_tex, 2),
		set(textures, [ctrl.rain_texture]),
		]
		where ctrl = find_or_die(level.chars, value is obj rain_effect_controller)
		"
	},
	
	{
		name: "shadow",
		new: true,
		vertex: "
			//boiler plate vertex shader. Probably doesn't need modification.
			//The fragment shader is where the fun is.
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		
		
		fragment: "
			#version 120
			uniform sampler2D u_anura_tex_map;
			uniform float u_shadow_opacity;
			uniform float u_shadow_red;
			uniform float u_shadow_green;
			uniform float u_shadow_blue;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;

			void main() {
				vec4 fb_color = texture2D(u_anura_tex_map,v_texcoord); //Get a pixel of the active layer.
				gl_FragColor = vec4(u_shadow_red, u_shadow_green, u_shadow_blue, (1-fb_color[0]) * u_shadow_opacity);
			}
		",
	},
	
	{
		name: "shadow2",
		new: true,
		vertex: "
			//boiler plate vertex shader. Probably doesn't need modification.
			//The fragment shader is where the fun is.
			uniform mat4 u_anura_mvp_matrix;
			//uniform float u_anura_cycle;
			//uniform vec4 u_anura_sprite_area;
			//uniform vec4 u_anura_draw_area;
			attribute vec2 a_anura_vertex;
			attribute vec2 a_anura_texcoord;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;
			void main()
			{
				v_vertex = a_anura_vertex;
				gl_Position = u_anura_mvp_matrix * vec4(a_anura_vertex, 0.0, 1.0);
				v_texcoord = a_anura_texcoord;
			}
		",
		
		
		fragment: "
			#version 120
			uniform sampler2D u_anura_tex_map;
			uniform float u_shadow_opacity;
			uniform float u_shadow_red;
			uniform float u_shadow_green;
			uniform float u_shadow_blue;
			varying vec2 v_texcoord;
			varying vec2 v_vertex;

			void main() {
				vec4 fb_color = texture2D(u_anura_tex_map, v_texcoord); //Get a pixel of the active layer.
				gl_FragColor = mix(
					vec4(u_shadow_red,  u_shadow_green, u_shadow_blue, u_shadow_opacity),
					vec4(1-fb_color[0], 1-fb_color[1],  1-fb_color[2], 0), //Change blend mode to multiplicative and then remove the `1-`s.
					fb_color[3]
				);
			}
		",
	},
	],
}
