{
id: "pullable_coordinator", //ie, levers.
prototype: ["pullable"],


properties: {
#-------------------------- constructor/destructor logic --------------------------#


#-------------------------- pullable overrides --------------------------#
	/*
		In these visual bits here, we're omitting the `animation` calls to pushed, because this is generally an invisible coordinator object.
	*/
	visually_turn_on: "commands :: [sound('switch.wav')]",
	visually_turn_off: "commands :: [sound('switch.wav')]", 


	is_this_active: "bool :: size(activated) = size(monitoring)",

#-------------------------- coordination logic --------------------------#
	add: "def(obj pullable_untracked lock) -> commands if(not lock in me.monitoring, [
		add(me.monitoring, [lock]),
		set(lock._lock_coordinator, me),
		
		fire_event(me,'do_coordination_setup')
	])",
	remove: "def(obj pullable_untracked lock) -> commands [
		set(me.monitoring, newMonitoring),
		set(lock._lock_coordinator, null),
	] where newMonitoring = filter(me.monitoring, value!=lock)",

	
	monitoring: { type: "[obj pullable_untracked]", default: [] },
	activated: { type: "[obj pullable_untracked]", default: [] },

#-------------------------- sample activation logic --------------------------#
	/*
		This is really the stuff that would change if you were going to build additional puzzles off of an object like this.
		
		Right now, this is simply set up so that if all of the coordinated objects are active, this is active.
		I.e. if you light all 4 braziers, then the 'unlock' happens.
	*/


	setup_list_of_locks: "commands :: [
		//I'm really not sure why this check is here, but maybe it's a workaround for a bug, or an affordance to let this not assert the editor before you've placed all the objects.
		if( size(monitoring) = size(filter(level.chars, value is obj pullable_untracked and value.event = me.event)),
			[
				if(_event != default_event_state, map( monitoring, add(activated, [value])))
			]
		),
	]",

	is_lock_active: "def(obj pullable_untracked lock) -> bool  (lock in activated)",

	activate: "def(obj pullable_untracked lock) -> commands [
		set(activated, unique(activated + [lock])),
		schedule(1, fire_event(me,'test_set')),
	]",
	
	deactivate: "def(obj pullable_untracked lock) -> commands [
		set(activated, filter(activated, not value = lock)),
		schedule(1, fire_event(me,'test_set')),
	]",

#-------------------------- event observance --------------------------#
	
},

on_test_set: "do_toggle",

on_do_coordination_setup: "setup_list_of_locks",

}