{
id: "pullable_coordinator", //ie, levers.
prototype: ["pullable"],


properties: {
#-------------------------- constructor/destructor logic --------------------------#

#-------------------------- coordination logic --------------------------#
	add: "def(obj pullable_untracked lock) -> commands [
		add(self.monitoring, [lock]),
		set(lock._lock_coordinator, self),
		
		fire_event(me,'do_coordination_setup')
	]",
	remove: "def(obj pullable_untracked lock) -> commands [
		set(self.monitoring, newMonitoring),
		set(lock._lock_coordinator, null),
	] where newMonitoring = filter(self.monitoring, value!=lock)",

	
	monitoring: { type: "[obj pullable_untracked]", default: [] },

#-------------------------- sample activation logic --------------------------#
	/*
		This is really the stuff that would change if you were going to build additional puzzles off of an object like this.
		
		Right now, this is simply set up so that if all of the coordinated objects are active, this is active.
		I.e. if you light all 4 braziers, then the 'unlock' happens.
	*/


	setup_list_of_locks: "commands :: [
		//I'm really not sure why this check is here, but maybe it's a workaround for a bug, or an affordance to let this not assert the editor before you've placed all the objects.
		if( size(monitoring) = size(filter(level.chars, value is obj pullable_untracked and value.event = me.event)),
			[
				if(_event != default_event_state, map( monitoring, add(activated, [value])))
			]
		),
	]",


	activate: "def(obj pullable_untracked lock) -> commands [
		add(activated, [lock]),
		schedule(1, fire_event(me,'test_set'))
	]",

#-------------------------- event observance --------------------------#
	
},

on_test_set: "if(size(activated) = size(monitoring), [
	do_toggle,
	//map(monitoring, value.big_flash)
])",

on_do_coordination_setup: "setup_list_of_locks",

}